<HTML>
<HEAD>
<TITLE>The RtAudio Tutorial</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.2.8.1 -->
<h1>RtAudio.h</h1><div class="fragment"><pre>00001 <font class="comment">/************************************************************************/</font>
00038 <font class="comment">/************************************************************************/</font>
00039 
00040 <font class="preprocessor">#if !defined(__RTAUDIO_H)</font>
00041 <font class="preprocessor"></font><font class="preprocessor">#define __RTAUDIO_H</font>
00042 <font class="preprocessor"></font>
00043 <font class="preprocessor">#include &lt;map&gt;</font>
00044 
00045 <font class="preprocessor">#if defined(__LINUX_ALSA__)</font>
00046 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;alsa/asoundlib.h&gt;</font>
00047 <font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00048 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00049 
00050   <font class="keyword">typedef</font> snd_pcm_t *AUDIO_HANDLE;
00051   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00052   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00053   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00054 
00055 <font class="preprocessor">#elif defined(__LINUX_OSS__)</font>
00056 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00057 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00058 
00059   <font class="keyword">typedef</font> <font class="keywordtype">int</font> AUDIO_HANDLE;
00060   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00061   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00062   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00063 
00064 <font class="preprocessor">#elif defined(__WINDOWS_DS__)</font>
00065 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;windows.h&gt;</font>
00066 <font class="preprocessor">  #include &lt;process.h&gt;</font>
00067 
00068   <font class="comment">// The following struct is used to hold the extra variables</font>
00069   <font class="comment">// specific to the DirectSound implementation.</font>
00070   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00071     <font class="keywordtype">void</font> * object;
00072     <font class="keywordtype">void</font> * buffer;
00073     UINT bufferPointer;
00074   } AUDIO_HANDLE;
00075 
00076   <font class="keyword">typedef</font> LPGUID DEVICE_ID;
00077   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> THREAD_HANDLE;
00078   <font class="keyword">typedef</font> CRITICAL_SECTION MUTEX;
00079 
00080 <font class="preprocessor">#elif defined(__WINDOWS_ASIO__)</font>
00081 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;windows.h&gt;</font>
00082 <font class="preprocessor">  #include &lt;process.h&gt;</font>
00083 
00084   <font class="keyword">typedef</font> <font class="keywordtype">int</font> AUDIO_HANDLE;
00085   <font class="keyword">typedef</font> <font class="keywordtype">int</font> DEVICE_ID;
00086   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> THREAD_HANDLE;
00087   <font class="keyword">typedef</font> CRITICAL_SECTION MUTEX;
00088 
00089 <font class="preprocessor">#elif defined(__IRIX_AL__)</font>
00090 <font class="preprocessor"></font><font class="preprocessor">  #include &lt;dmedia/audio.h&gt;</font>
00091 <font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00092 <font class="preprocessor">  #include &lt;unistd.h&gt;</font>
00093 
00094   <font class="keyword">typedef</font> ALport AUDIO_HANDLE;
00095   <font class="keyword">typedef</font> <font class="keywordtype">long</font> DEVICE_ID;
00096   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00097   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00098 
00099 <font class="preprocessor">#elif defined(__MACOSX_CORE__)</font>
00100 <font class="preprocessor"></font>
00101 <font class="preprocessor">  #include &lt;CoreAudio/AudioHardware.h&gt;</font>
00102 <font class="preprocessor">  #include &lt;pthread.h&gt;</font>
00103 
00104   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> AUDIO_HANDLE;
00105   <font class="keyword">typedef</font> AudioDeviceID DEVICE_ID;
00106   <font class="keyword">typedef</font> pthread_t THREAD_HANDLE;
00107   <font class="keyword">typedef</font> pthread_mutex_t MUTEX;
00108 
00109 <font class="preprocessor">#endif</font>
00110 <font class="preprocessor"></font>
00111 
00112 <font class="comment">/************************************************************************/</font>
00125 <font class="comment">/************************************************************************/</font>
00126 
00127 <font class="keyword">class </font><a class="code" href="classRtError.html">RtError</a>
00128 {
00129 <font class="keyword">public</font>:
<a name="l00131"></a><a class="code" href="classRtError.html#s11">00131</a>   <font class="keyword">enum</font> TYPE {
00132     WARNING,
00133     DEBUG_WARNING,
00134     UNSPECIFIED,
00135     NO_DEVICES_FOUND,
00136     INVALID_DEVICE,
00137     INVALID_STREAM,
00138     MEMORY_ERROR,
00139     INVALID_PARAMETER,
00140     DRIVER_ERROR,
00141     SYSTEM_ERROR,
00142     THREAD_ERROR
00143   };
00144 
00145 <font class="keyword">protected</font>:
00146   <font class="keywordtype">char</font> error_message[256];
00147   TYPE type;
00148 
00149 <font class="keyword">public</font>:
00151   <a class="code" href="classRtError.html#a0">RtError</a>(<font class="keyword">const</font> <font class="keywordtype">char</font> *p, TYPE tipe = RtError::UNSPECIFIED);
00152 
00154   <font class="keyword">virtual</font> <a class="code" href="classRtError.html#a1">~RtError</a>(<font class="keywordtype">void</font>);
00155 
00157   <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classRtError.html#a2">printMessage</a>(<font class="keywordtype">void</font>);
00158 
<a name="l00160"></a><a class="code" href="classRtError.html#a3">00160</a>   <font class="keyword">virtual</font> <font class="keyword">const</font> TYPE&amp; <a class="code" href="classRtError.html#a3">getType</a>(<font class="keywordtype">void</font>)<font class="keyword"> </font>{ <font class="keywordflow">return</font> type; }
00161 
<a name="l00163"></a><a class="code" href="classRtError.html#a4">00163</a>   <font class="keyword">virtual</font> <font class="keyword">const</font> <font class="keywordtype">char</font> *<a class="code" href="classRtError.html#a4">getMessage</a>(<font class="keywordtype">void</font>)<font class="keyword"> </font>{ <font class="keywordflow">return</font> error_message; }
00164 };
00165 
00166 
00167 <font class="comment">// This public structure type is used to pass callback information</font>
00168 <font class="comment">// between the private RtAudio stream structure and global callback</font>
00169 <font class="comment">// handling functions.</font>
00170 <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00171   <font class="keywordtype">void</font> *object;  <font class="comment">// Used as a "this" pointer.</font>
00172   <font class="keywordtype">int</font> streamId;
00173   DEVICE_ID device[2];
00174   THREAD_HANDLE thread;
00175   <font class="keywordtype">void</font> *callback;
00176   <font class="keywordtype">void</font> *buffers;
00177   <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> waitTime;
00178   <font class="keywordtype">bool</font> blockTick;
00179   <font class="keywordtype">bool</font> stopStream;
00180   <font class="keywordtype">bool</font> usingCallback;
00181   <font class="keywordtype">void</font> *userData;
00182 } CALLBACK_INFO;
00183 
00184 
00185 <font class="comment">// *************************************************** //</font>
00186 <font class="comment">//</font>
00187 <font class="comment">// RtAudio class declaration.</font>
00188 <font class="comment">//</font>
00189 <font class="comment">// *************************************************** //</font>
00190 
00191 <font class="keyword">class </font><a class="code" href="classRtAudio.html">RtAudio</a>
00192 {
00193 <font class="keyword">public</font>:
00194 
00195   <font class="comment">// Support for signed integers and floats.  Audio data fed to/from</font>
00196   <font class="comment">// the tickStream() routine is assumed to ALWAYS be in host</font>
00197   <font class="comment">// byte order.  The internal routines will automatically take care of</font>
00198   <font class="comment">// any necessary byte-swapping between the host format and the</font>
00199   <font class="comment">// soundcard.  Thus, endian-ness is not a concern in the following</font>
00200   <font class="comment">// format definitions.</font>
00201   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> RTAUDIO_FORMAT;
<a name="l00202"></a><a class="code" href="classRtAudio.html#p0">00202</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT8; 
<a name="l00203"></a><a class="code" href="classRtAudio.html#p1">00203</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT16; 
<a name="l00204"></a><a class="code" href="classRtAudio.html#p2">00204</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT24; 
<a name="l00205"></a><a class="code" href="classRtAudio.html#p3">00205</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_SINT32; 
<a name="l00206"></a><a class="code" href="classRtAudio.html#p4">00206</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_FLOAT32; 
<a name="l00207"></a><a class="code" href="classRtAudio.html#p5">00207</a>   <font class="keyword">static</font> <font class="keyword">const</font> RTAUDIO_FORMAT RTAUDIO_FLOAT64; 
00209   <font class="comment">//static const int MAX_SAMPLE_RATES = 14;</font>
00210   <font class="keyword">enum</font> { MAX_SAMPLE_RATES = 14 };
00211 
00212   <font class="keyword">typedef</font> int (*RTAUDIO_CALLBACK)(<font class="keywordtype">char</font> *buffer, <font class="keywordtype">int</font> bufferSize, <font class="keywordtype">void</font> *userData);
00213 
<a name="l00215"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html">00215</a>   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
<a name="l00216"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m0">00216</a>     <font class="keywordtype">char</font> name[128];    
00217     DEVICE_ID id[2];  <font class="comment">/* No value reported by getDeviceInfo(). */</font>
<a name="l00218"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m2">00218</a>     <font class="keywordtype">bool</font> probed;       
<a name="l00219"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m3">00219</a>     <font class="keywordtype">int</font> maxOutputChannels; 
<a name="l00220"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m4">00220</a>     <font class="keywordtype">int</font> maxInputChannels;  
<a name="l00221"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m5">00221</a>     <font class="keywordtype">int</font> maxDuplexChannels; 
<a name="l00222"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m6">00222</a>     <font class="keywordtype">int</font> minOutputChannels; 
<a name="l00223"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m7">00223</a>     <font class="keywordtype">int</font> minInputChannels;  
<a name="l00224"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m8">00224</a>     <font class="keywordtype">int</font> minDuplexChannels; 
<a name="l00225"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m9">00225</a>     <font class="keywordtype">bool</font> hasDuplexSupport; 
<a name="l00226"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m10">00226</a>     <font class="keywordtype">bool</font> isDefault;        
<a name="l00227"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m11">00227</a>     <font class="keywordtype">int</font> nSampleRates;      
<a name="l00228"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m12">00228</a>     <font class="keywordtype">int</font> sampleRates[MAX_SAMPLE_RATES]; 
<a name="l00229"></a><a class="code" href="structRtAudio_1_1RTAUDIO__DEVICE.html#m13">00229</a>     RTAUDIO_FORMAT nativeFormats;     
00230   } RTAUDIO_DEVICE;
00231 
00233 
00239   <a class="code" href="classRtAudio.html#a0">RtAudio</a>();
00240 
00242 
00253   <a class="code" href="classRtAudio.html#a0">RtAudio</a>(<font class="keywordtype">int</font> *streamId,
00254           <font class="keywordtype">int</font> outputDevice, <font class="keywordtype">int</font> outputChannels,
00255           <font class="keywordtype">int</font> inputDevice, <font class="keywordtype">int</font> inputChannels,
00256           RTAUDIO_FORMAT format, <font class="keywordtype">int</font> sampleRate,
00257           <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00258 
00260 
00264   <a class="code" href="classRtAudio.html#a2">~RtAudio</a>();
00265 
00267 
00294   <font class="keywordtype">int</font> <a class="code" href="classRtAudio.html#a3">openStream</a>(<font class="keywordtype">int</font> outputDevice, <font class="keywordtype">int</font> outputChannels,
00295                  <font class="keywordtype">int</font> inputDevice, <font class="keywordtype">int</font> inputChannels,
00296                  RTAUDIO_FORMAT format, <font class="keywordtype">int</font> sampleRate,
00297                  <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00298 
00300 
00319   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a4">setStreamCallback</a>(<font class="keywordtype">int</font> streamId, RTAUDIO_CALLBACK callback, <font class="keywordtype">void</font> *userData);
00320 
00322 
00329   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a5">cancelStreamCallback</a>(<font class="keywordtype">int</font> streamId);
00330 
00332   <font class="keywordtype">int</font> <a class="code" href="classRtAudio.html#a6">getDeviceCount</a>(<font class="keywordtype">void</font>);
00333 
00335 
00343   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a7">getDeviceInfo</a>(<font class="keywordtype">int</font> device, RTAUDIO_DEVICE *info);
00344 
00346 
00351   <font class="keywordtype">char</font> * <font class="keyword">const</font> <a class="code" href="classRtAudio.html#a8">getStreamBuffer</a>(<font class="keywordtype">int</font> streamId);
00352 
00354 
00359   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a9">tickStream</a>(<font class="keywordtype">int</font> streamId);
00360 
00362 
00366   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a10">closeStream</a>(<font class="keywordtype">int</font> streamId);
00367 
00369 
00373   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a11">startStream</a>(<font class="keywordtype">int</font> streamId);
00374 
00376 
00380   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a12">stopStream</a>(<font class="keywordtype">int</font> streamId);
00381 
00383 
00387   <font class="keywordtype">void</font> <a class="code" href="classRtAudio.html#a13">abortStream</a>(<font class="keywordtype">int</font> streamId);
00388 
00390 
00395   <font class="keywordtype">int</font> <a class="code" href="classRtAudio.html#a14">streamWillBlock</a>(<font class="keywordtype">int</font> streamId);
00396 
00397 <font class="preprocessor">#if (defined(__MACOSX_CORE__) || defined(__WINDOWS_ASIO__))</font>
00398 <font class="preprocessor"></font>  <font class="comment">// This function is intended for internal use only.  It must be</font>
00399   <font class="comment">// public because it is called by the internal callback handler,</font>
00400   <font class="comment">// which is not a member of RtAudio.  External use of this function</font>
00401   <font class="comment">// will most likely produce highly undesireable results!</font>
00402   <font class="keywordtype">void</font> callbackEvent(<font class="keywordtype">int</font> streamId, DEVICE_ID deviceId, <font class="keywordtype">void</font> *inData, <font class="keywordtype">void</font> *outData);
00403 <font class="preprocessor">#endif</font>
00404 <font class="preprocessor"></font>
00405 <font class="keyword">protected</font>:
00406 
00407 <font class="keyword">private</font>:
00408 
00409   <font class="keyword">static</font> <font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> SAMPLE_RATES[MAX_SAMPLE_RATES];
00410 
00411   <font class="keyword">enum</font> { FAILURE, SUCCESS };
00412 
00413   <font class="keyword">enum</font> STREAM_MODE {
00414     OUTPUT,
00415     INPUT,
00416     DUPLEX,
00417     UNINITIALIZED = -75
00418   };
00419 
00420   <font class="keyword">enum</font> STREAM_STATE {
00421     STREAM_STOPPED,
00422     STREAM_RUNNING
00423   };
00424 
00425   <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00426     <font class="keywordtype">int</font> device[2];          <font class="comment">// Playback and record, respectively.</font>
00427     STREAM_MODE mode;       <font class="comment">// OUTPUT, INPUT, or DUPLEX.</font>
00428     AUDIO_HANDLE handle[2]; <font class="comment">// Playback and record handles, respectively.</font>
00429     STREAM_STATE state;     <font class="comment">// STOPPED or RUNNING</font>
00430     <font class="keywordtype">char</font> *userBuffer;
00431     <font class="keywordtype">char</font> *deviceBuffer;
00432     <font class="keywordtype">bool</font> doConvertBuffer[2]; <font class="comment">// Playback and record, respectively.</font>
00433     <font class="keywordtype">bool</font> deInterleave[2];    <font class="comment">// Playback and record, respectively.</font>
00434     <font class="keywordtype">bool</font> doByteSwap[2];      <font class="comment">// Playback and record, respectively.</font>
00435     <font class="keywordtype">int</font> sampleRate;
00436     <font class="keywordtype">int</font> bufferSize;
00437     <font class="keywordtype">int</font> nBuffers;
00438     <font class="keywordtype">int</font> nUserChannels[2];    <font class="comment">// Playback and record, respectively.</font>
00439     <font class="keywordtype">int</font> nDeviceChannels[2];  <font class="comment">// Playback and record channels, respectively.</font>
00440     RTAUDIO_FORMAT userFormat;
00441     RTAUDIO_FORMAT deviceFormat[2]; <font class="comment">// Playback and record, respectively.</font>
00442     MUTEX mutex;
00443     CALLBACK_INFO callbackInfo;
00444   } RTAUDIO_STREAM;
00445 
00446   <font class="keyword">typedef</font> <font class="keywordtype">signed</font> <font class="keywordtype">short</font> INT16;
00447   <font class="keyword">typedef</font> <font class="keywordtype">signed</font> <font class="keywordtype">int</font> INT32;
00448   <font class="keyword">typedef</font> <font class="keywordtype">float</font> FLOAT32;
00449   <font class="keyword">typedef</font> <font class="keywordtype">double</font> FLOAT64;
00450 
00451   <font class="keywordtype">char</font> message[256];
00452   <font class="keywordtype">int</font> nDevices;
00453   RTAUDIO_DEVICE *devices;
00454 
00455   std::map&lt;int, void *&gt; streams;
00456 
00458   <font class="keywordtype">void</font> error(RtError::TYPE type);
00459 
00464   <font class="keywordtype">void</font> initialize(<font class="keywordtype">void</font>);
00465 
00470   <font class="keywordtype">int</font> getDefaultInputDevice(<font class="keywordtype">void</font>);
00471 
00476   <font class="keywordtype">int</font> getDefaultOutputDevice(<font class="keywordtype">void</font>);
00477 
00479   <font class="keywordtype">void</font> clearDeviceInfo(RTAUDIO_DEVICE *info);
00480 
00488   <font class="keywordtype">void</font> probeDeviceInfo(RTAUDIO_DEVICE *info);
00489 
00496   <font class="keywordtype">bool</font> probeDeviceOpen(<font class="keywordtype">int</font> device, RTAUDIO_STREAM *stream,
00497                        STREAM_MODE mode, <font class="keywordtype">int</font> channels, 
00498                        <font class="keywordtype">int</font> sampleRate, RTAUDIO_FORMAT format,
00499                        <font class="keywordtype">int</font> *bufferSize, <font class="keywordtype">int</font> numberOfBuffers);
00500 
00507   <font class="keywordtype">void</font> *verifyStream(<font class="keywordtype">int</font> streamId);
00508 
00513   <font class="keywordtype">void</font> convertStreamBuffer(RTAUDIO_STREAM *stream, STREAM_MODE mode);
00514 
00516   <font class="keywordtype">void</font> byteSwapBuffer(<font class="keywordtype">char</font> *buffer, <font class="keywordtype">int</font> samples, RTAUDIO_FORMAT format);
00517 
00519   <font class="keywordtype">int</font> formatBytes(RTAUDIO_FORMAT format);
00520 };
00521 
00522 <font class="comment">// Define the following flag to have extra information spewed to stderr.</font>
00523 <font class="comment">//#define __RTAUDIO_DEBUG__</font>
00524 
00525 <font class="preprocessor">#endif</font>
</font></pre></div><HR>

<table><tr><td><img src="../images/ccrma.gif">
  <td>&copy;2001-2002 Gary P. Scavone, CCRMA, Stanford University. All Rights Reserved.<br>
  Maintained by Gary P. Scavone, <a href="mailto:gary@ccrma.stanford.edu">gary@ccrma.stanford.edu</a><P>
</table>

</BODY>
</HTML>
